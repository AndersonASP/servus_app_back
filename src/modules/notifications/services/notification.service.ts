import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from 'src/modules/users/schema/user.schema';
import { Membership } from 'src/modules/membership/schemas/membership.schema';
import { MembershipRole } from 'src/common/enums/role.enum';

export interface NotificationData {
  id: string;
  type:
    | 'user_created'
    | 'user_profile_completed'
    | 'membership_created'
    | 'user_joined_ministry'
    | 'volunteer_submission_pending' // üÜï Nova submiss√£o de volunt√°rio
    | 'volunteer_submission_approved' // üÜï Volunt√°rio aprovado
    | 'volunteer_submission_rejected'; // üÜï Volunt√°rio rejeitado
  title: string;
  message: string;
  data: any;
  recipients: string[]; // User IDs
  tenantId: string;
  branchId?: string;
  ministryId?: string;
  createdAt: Date;
  readBy: string[]; // User IDs que j√° leram
  actionUrl?: string;
}

@Injectable()
export class NotificationService {
  private notifications: NotificationData[] = []; // Em produ√ß√£o, usar MongoDB

  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
    @InjectModel(Membership.name) private memModel: Model<Membership>,
  ) {}

  // üîî Notificar cria√ß√£o de novo usu√°rio
  async notifyNewUser(
    newUser: any,
    membership: any,
    createdBy: string,
  ): Promise<void> {
    try {
      // Buscar admins que devem ser notificados
      const recipients = await this.getNotificationRecipients(
        membership.tenant,
        membership.branch,
        ['tenant_admin', 'branch_admin'],
      );

      // Criar notifica√ß√£o
      const notification: NotificationData = {
        id: this.generateId(),
        type: 'user_created',
        title: 'üë§ Novo usu√°rio criado',
        message: `${newUser.name} foi criado como ${this.translateRole(membership.role)} por ${createdBy}`,
        data: {
          userId: newUser._id,
          userName: newUser.name,
          userEmail: newUser.email,
          userRole: membership.role,
          branchId: membership.branch,
          ministryId: membership.ministry,
          createdBy,
        },
        recipients: recipients.map((r) => r._id.toString()),
        tenantId: membership.tenant.toString(),
        branchId: membership.branch?.toString(),
        ministryId: membership.ministry?.toString(),
        createdAt: new Date(),
        readBy: [],
        actionUrl: `/users/${newUser._id}`,
      };

      // Salvar notifica√ß√£o
      this.notifications.push(notification);

      console.log(
        `üîî Notifica√ß√£o criada: ${notification.title} para ${recipients.length} usu√°rios`,
      );

      // Em produ√ß√£o, enviar por WebSocket, email, push notification, etc.
      await this.sendNotificationToUsers(notification, recipients);
    } catch (error) {
      console.error(
        '‚ùå Erro ao criar notifica√ß√£o de novo usu√°rio:',
        error.message,
      );
    }
  }

  // üîî Notificar perfil completado
  async notifyProfileCompleted(
    user: any,
    tenantId: string,
    branchId?: string,
  ): Promise<void> {
    try {
      const recipients = await this.getNotificationRecipients(
        tenantId,
        branchId,
        ['tenant_admin', 'branch_admin', 'leader'],
      );

      const notification: NotificationData = {
        id: this.generateId(),
        type: 'user_profile_completed',
        title: '‚úÖ Perfil completado',
        message: `${user.name} completou seu perfil e est√° pronto para servir!`,
        data: {
          userId: user._id,
          userName: user.name,
          userEmail: user.email,
          skills: user.skills,
          availability: user.availability,
        },
        recipients: recipients.map((r) => r._id.toString()),
        tenantId: tenantId.toString(),
        branchId: branchId?.toString(),
        createdAt: new Date(),
        readBy: [],
        actionUrl: `/users/${user._id}`,
      };

      this.notifications.push(notification);
      await this.sendNotificationToUsers(notification, recipients);

      console.log(`üîî Notifica√ß√£o de perfil completado: ${user.name}`);
    } catch (error) {
      console.error('‚ùå Erro ao notificar perfil completado:', error.message);
    }
  }

  // üîî Notificar usu√°rio adicionado ao ministry
  async notifyUserJoinedMinistry(
    user: any,
    membership: any,
    ministryName: string,
  ): Promise<void> {
    try {
      // Buscar leaders do ministry
      const recipients = await this.getMinistryLeaders(
        membership.tenant,
        membership.ministry,
      );

      const notification: NotificationData = {
        id: this.generateId(),
        type: 'user_joined_ministry',
        title: '‚õ™ Novo membro no minist√©rio',
        message: `${user.name} se juntou ao minist√©rio ${ministryName}`,
        data: {
          userId: user._id,
          userName: user.name,
          userEmail: user.email,
          ministryName,
          userRole: membership.role,
        },
        recipients: recipients.map((r) => r._id.toString()),
        tenantId: membership.tenant.toString(),
        branchId: membership.branch?.toString(),
        ministryId: membership.ministry?.toString(),
        createdAt: new Date(),
        readBy: [],
        actionUrl: `/ministries/${membership.ministry}/members`,
      };

      this.notifications.push(notification);
      await this.sendNotificationToUsers(notification, recipients);

      console.log(
        `üîî Notifica√ß√£o de novo membro no minist√©rio: ${ministryName}`,
      );
    } catch (error) {
      console.error(
        '‚ùå Erro ao notificar novo membro no minist√©rio:',
        error.message,
      );
    }
  }

  // üìã Listar notifica√ß√µes do usu√°rio
  async getUserNotifications(
    userId: string,
    options: { page: number; limit: number; unreadOnly?: boolean },
  ): Promise<{
    notifications: NotificationData[];
    total: number;
    unreadCount: number;
  }> {
    const userNotifications = this.notifications
      .filter((n) => n.recipients.includes(userId))
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    const unreadCount = userNotifications.filter(
      (n) => !n.readBy.includes(userId),
    ).length;

    let filtered = userNotifications;
    if (options.unreadOnly) {
      filtered = userNotifications.filter((n) => !n.readBy.includes(userId));
    }

    const startIndex = (options.page - 1) * options.limit;
    const endIndex = startIndex + options.limit;
    const paginatedNotifications = filtered.slice(startIndex, endIndex);

    return {
      notifications: paginatedNotifications,
      total: filtered.length,
      unreadCount,
    };
  }

  // ‚úÖ Marcar notifica√ß√£o como lida
  async markAsRead(notificationId: string, userId: string): Promise<void> {
    const notification = this.notifications.find(
      (n) => n.id === notificationId,
    );
    if (notification && !notification.readBy.includes(userId)) {
      notification.readBy.push(userId);
      console.log(
        `‚úÖ Notifica√ß√£o ${notificationId} marcada como lida por ${userId}`,
      );
    }
  }

  // ‚úÖ Marcar todas as notifica√ß√µes como lidas
  async markAllAsRead(userId: string): Promise<void> {
    const userNotifications = this.notifications.filter(
      (n) => n.recipients.includes(userId) && !n.readBy.includes(userId),
    );

    userNotifications.forEach((n) => n.readBy.push(userId));
    console.log(
      `‚úÖ ${userNotifications.length} notifica√ß√µes marcadas como lidas para ${userId}`,
    );
  }

  // üîç Buscar recipients para notifica√ß√£o
  private async getNotificationRecipients(
    tenantId: string,
    branchId?: string,
    roles: string[] = ['tenant_admin', 'branch_admin'],
  ): Promise<any[]> {
    const filter: any = {
      tenant: tenantId,
      role: { $in: roles },
      isActive: true,
    };

    if (branchId) {
      // Se h√° branchId, buscar admins da branch E admins do tenant
      const branchAdmins = await this.memModel
        .find({ ...filter, branch: branchId })
        .populate('user', '_id name email')
        .lean();

      const tenantAdmins = await this.memModel
        .find({
          tenant: tenantId,
          role: 'tenant_admin',
          isActive: true,
        })
        .populate('user', '_id name email')
        .lean();

      return [...branchAdmins, ...tenantAdmins]
        .map((m) => m.user)
        .filter(
          (user, index, self) =>
            index ===
            self.findIndex((u) => u._id.toString() === user._id.toString()),
        );
    }

    const memberships = await this.memModel
      .find(filter)
      .populate('user', '_id name email')
      .lean();

    return memberships.map((m) => m.user);
  }

  // üîç Buscar leaders de um ministry
  private async getMinistryLeaders(
    tenantId: string,
    ministryId: string,
  ): Promise<any[]> {
    const memberships = await this.memModel
      .find({
        tenant: tenantId,
        ministry: ministryId,
        role: MembershipRole.Leader,
        isActive: true,
      })
      .populate('user', '_id name email')
      .lean();

    return memberships.map((m) => m.user);
  }

  // üì® Enviar notifica√ß√£o para usu√°rios (implementar canais)
  private async sendNotificationToUsers(
    notification: NotificationData,
    recipients: any[],
  ): Promise<void> {
    // Em produ√ß√£o, implementar diferentes canais:
    console.log(`üì® Enviando notifica√ß√£o para ${recipients.length} usu√°rios:`);
    console.log(`   üìß Email: ${recipients.map((r) => r.email).join(', ')}`);
    console.log(`   üì± Push: ${notification.title}`);
    console.log(`   üåê WebSocket: Notifica√ß√£o em tempo real`);

    // Simular envio de email/push/websocket
    recipients.forEach((recipient) => {
      console.log(
        `   ‚Üí ${recipient.name} (${recipient.email}): ${notification.message}`,
      );
    });
  }

  // üîÑ Traduzir roles
  private translateRole(role: string): string {
    const translations: { [key: string]: string } = {
      tenant_admin: 'Administrador da Igreja',
      branch_admin: 'Administrador da Filial',
      leader: 'L√≠der',
      volunteer: 'Volunt√°rio',
    };
    return translations[role] || role;
  }

  // üÜî Gerar ID √∫nico
  private generateId(): string {
    return `notification_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  }

  // üÜï Notificar l√≠deres sobre nova submiss√£o de volunt√°rio
  async notifyMinistryLeadersAboutSubmission(
    submission: any,
    ministryId: string,
    tenantId: string,
  ): Promise<void> {
    try {
      console.log(`üîî [NotificationService] Notificando l√≠deres sobre submiss√£o de volunt√°rio`);

      // Buscar l√≠deres do minist√©rio
      const leaders = await this.getMinistryLeaders(tenantId, ministryId);
      
      if (leaders.length === 0) {
        console.log(`‚ö†Ô∏è [NotificationService] Nenhum l√≠der encontrado para minist√©rio ${ministryId}`);
        return;
      }

      const notification: NotificationData = {
        id: `submission_${submission._id}`,
        type: 'volunteer_submission_pending',
        title: 'Nova Submiss√£o de Volunt√°rio',
        message: `${submission.volunteerName} submeteu candidatura para o minist√©rio`,
        data: {
          submissionId: submission._id,
          volunteerName: submission.volunteerName,
          volunteerEmail: submission.email,
          ministryId,
          selectedFunctions: submission.selectedFunctions || [],
        },
        recipients: leaders.map(leader => leader._id.toString()),
        tenantId,
        ministryId,
        createdAt: new Date(),
        readBy: [],
        actionUrl: `/ministry-approvals/ministries/${ministryId}/pending`,
      };

      await this.sendNotificationToUsers(notification, leaders);
      
      console.log(`‚úÖ [NotificationService] Notifica√ß√£o enviada para ${leaders.length} l√≠deres`);
    } catch (error) {
      console.error('‚ùå [NotificationService] Erro ao notificar l√≠deres:', error);
    }
  }

  // üÜï Notificar volunt√°rio sobre aprova√ß√£o/rejei√ß√£o
  async notifyVolunteerAboutDecision(
    submission: any,
    decision: 'approved' | 'rejected',
    leaderName: string,
    notes?: string,
  ): Promise<void> {
    try {
      console.log(`üîî [NotificationService] Notificando volunt√°rio sobre decis√£o: ${decision}`);

      const notification: NotificationData = {
        id: `decision_${submission._id}`,
        type: decision === 'approved' ? 'volunteer_submission_approved' : 'volunteer_submission_rejected',
        title: decision === 'approved' ? 'Candidatura Aprovada!' : 'Candidatura N√£o Aprovada',
        message: decision === 'approved' 
          ? `Sua candidatura foi aprovada por ${leaderName}. Bem-vindo ao minist√©rio!`
          : `Sua candidatura n√£o foi aprovada por ${leaderName}. ${notes || ''}`,
        data: {
          submissionId: submission._id,
          volunteerName: submission.volunteerName,
          volunteerEmail: submission.email,
          ministryId: submission.preferredMinistry,
          decision,
          leaderName,
          notes,
        },
        recipients: [submission.email], // Usar email como identificador
        tenantId: submission.tenantId.toString(),
        ministryId: submission.preferredMinistry?.toString(),
        createdAt: new Date(),
        readBy: [],
        actionUrl: decision === 'approved' ? '/dashboard' : '/forms',
      };

      // Para notifica√ß√µes de volunt√°rios, enviar por email
      await this.sendVolunteerEmailNotification(notification);
      
      console.log(`‚úÖ [NotificationService] Notifica√ß√£o de ${decision} enviada para ${submission.email}`);
    } catch (error) {
      console.error('‚ùå [NotificationService] Erro ao notificar volunt√°rio:', error);
    }
  }

  // üÜï Enviar notifica√ß√£o por email para volunt√°rios
  private async sendVolunteerEmailNotification(notification: NotificationData): Promise<void> {
    // TODO: Implementar envio de email espec√≠fico para volunt√°rios
    console.log('üìß Email de notifica√ß√£o para volunt√°rio:', {
      type: notification.type,
      title: notification.title,
      recipient: notification.recipients[0],
    });
  }

  // üìä Estat√≠sticas de notifica√ß√µes
  async getNotificationStats(userId: string): Promise<{
    total: number;
    unread: number;
    byType: { [key: string]: number };
    recentCount: number;
  }> {
    const userNotifications = this.notifications.filter((n) =>
      n.recipients.includes(userId),
    );
    const unreadNotifications = userNotifications.filter(
      (n) => !n.readBy.includes(userId),
    );

    // Notifica√ß√µes das √∫ltimas 24 horas
    const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const recentNotifications = userNotifications.filter(
      (n) => n.createdAt > yesterday,
    );

    // Estat√≠sticas por tipo
    const byType: { [key: string]: number } = {};
    userNotifications.forEach((n) => {
      byType[n.type] = (byType[n.type] || 0) + 1;
    });

    return {
      total: userNotifications.length,
      unread: unreadNotifications.length,
      byType,
      recentCount: recentNotifications.length,
    };
  }
}
